## **`typedef` 和 `typename`**

  >  `typedef` 用来定义别名，`typename`用来告诉编译器后面的东西为一个类型即`type`

## **拷贝构造和拷贝赋值**

  > 拷贝赋值用于赋值。
  >
  > ```c++
  > Person p;
  > Person p1;
  > p = p1;//此时调用拷贝构造函数
  > ```
  >
  > - 初始化是对于一个新的对象来说的，在构造这个对象的时候，给这片内存一个初始值
  > - 赋值是对于一个已经存在的对象来说的，给一个已经存在的对象重新覆盖值

  > 拷贝构造的调用有如下几个场景：
  >
  > - 用`=`初始化一个新的类： `Person p = p1;`，此时的`=`代表初始化，并非赋值。
  >
  > - 显示调用拷贝构造函数来初始化一个新的类：`Person p(p1)`
  >
  > - 函数传参时，传入一个类的实参会导致拷贝构造生成一个临时对象：
  >
  >   ```c++
  >   void f(Person p1) { ... }
  >   Person p;
  >   f(p)
  >   ```

## **c++在函数后加const的意义**

  > 我们定义的类的[成员函数](https://so.csdn.net/so/search?q=成员函数&spm=1001.2101.3001.7020)中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是"只读"函数，而有一些函数要修改类数据成员的值。如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，它还能提高程序的可靠性，**已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理**。 const成员函数和const对象 实际上，const成员函数还有另外一项作用，即常量对象相关。对于内置的数据类型，我们可以定义它们的常量，用户自定义的类也一样，可以定义它们的常量对象。
  > 1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）
  > 2、表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中， 任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）；
  > 3、唯一的例外是对于mutable修饰的成员。加了const的成员函数可以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用